/*
 * "Advanced Programming in the Unix Environment" final assignment
*/

/*
 * sish: a simple shell
 * 12/20/2021
*/
#include "builtins.h"
#include "sish.h"
#include "str.h"

/*
 * Usage: sish [-x] [-c command]
*/

/*
 * Allocates memory to the command_struct
*/
command_struct*
create_command_struct(char* input)
{
	int inputlen;
	struct command_struct *command;
	inputlen = strlen(input) + 1;
	if ((command = calloc(1, ARG_MAX)) == NULL) {
		err(EXIT_FAILURE, "calloc");
	}
	if ((command->raw = calloc(1, sizeof(char*) * (inputlen))) == NULL) {
		err(EXIT_FAILURE, "calloc");
	}
	(void)strncpy(command->raw, input, inputlen);
	command->raw[inputlen] = '\0';
	command->num_pipes = 0;
	return command;
}

/*
 * Executes the command struct generated by the user input
*/
int
execute_command(struct command_struct* command) 
{
	/* iteration flags */
	char* token;
	int readspaces = 0;
	int end_index, start_index, status, i, j;
	int subcommandindex;
	pid_t pid;
	char *subcommand[ARG_MAX];

	/* piping and redirect variables */
	char* redirectfile = NULL;
	char* stdinfile = NULL;
	int openflags;
	int pipeoutput;
	int readpipe;
	int background;
	
	
	openflags = O_CREAT | O_RDWR;
	readpipe = -1;
	
	/* For each command group */	
	for (i = 0; i < command->num_pipes - 1; i++) {
		start_index = command->pipe_indexes[i];
		end_index = command->pipe_indexes[i + 1];
		if (end_index == -1) {
			end_index = command->num_tokens;
		}
		if (start_index != 0) {
			start_index ++;
		}
		
		subcommandindex = 0;
		readspaces = 0;
		pipeoutput = 0;
		int cpipe[2];
		background = 0;
		
		/* Process each command group from left to right and create a subcommand */
		for (j = start_index; j < end_index; j++) {
			token = command->tokenized[j];
			/* If not an echo, skip the spaces  */
			if (token && !readspaces && token[0] == ' ') {
				continue;
			}
			if (token && strncmp(token, "<", strlen(token) ) == 0) {
				if (j + 1 < end_index - 1&& command->tokenized[j+1][0] != ' ') {
					stdinfile = command->tokenized[j+1];
					j++;
				} else if (j + 2 < end_index - 1 && command->tokenized[j+2][0] != ' ') {
					stdinfile = command->tokenized[j+2];
					j+=2;
				} else { 
					(void)fprintf(stderr, "Syntax error on <\n"); 	
					command->exit_code = SYNTAX_ERR;
					return command->exit_code;
				}
			} else if (token && strncmp(token,  ">", strlen(token)) == 0) {
				if (j + 1 < end_index - 1 && command->tokenized[j+1][0] != ' ') {
					redirectfile = command->tokenized[j+1];
					j++;
				} else if (j + 2 < end_index - 1 && command->tokenized[j+2][0] != ' ') {
					redirectfile = command->tokenized[j+2];
					j+=2;
				} else { 
					(void)fprintf(stderr, "Syntax error on >\n"); 	
					command->exit_code = SYNTAX_ERR;
					return command->exit_code;
				}
			} else if (token && strncmp(token, ">>", strlen(token)) == 0) {
				if (j + 1 < end_index  - 1 && command->tokenized[j+1][0] != ' ') {
					redirectfile = command->tokenized[j+1];
					j++;
				} else if (j + 2 < end_index -1 && command->tokenized[j+2][0] != ' ') {
					redirectfile = command->tokenized[j+2];
					j+=2;
				} else { 
					(void)fprintf(stderr, "Syntax error on >>\n"); 	
					command->exit_code = SYNTAX_ERR;
					return command->exit_code;
				}
				openflags |= O_APPEND;
			} else if (token && strncmp(token, "&", strlen(token)) == 0) {
				background = 1;
				j++;
			} else if (token) {
				subcommand[subcommandindex] = token;
				if (!readspaces && strncmp(token, ECHO_BUILTIN, strlen(token)) == 0) {
					readspaces = 1;
				}
				subcommandindex++;
			} else  {
				continue;
			}
		}
		if (subcommandindex == 0) {
			(void) fprintf(stderr, "Syntax error: No command given\n");
			command->exit_code = SYNTAX_ERR;
			return command->exit_code;
		}
		
		if (end_index != command->num_tokens && !redirectfile && !stdinfile) {
			pipeoutput = 1;
			if (pipe2(cpipe, O_NONBLOCK)) {
				err(EXIT_FAILURE, "pipe2");
			}
		}
		subcommand[subcommandindex] = NULL;
		
		/* Print subcommands if tracing is enabled */
		if (flags.x) {
			int increment = 0;
			(void)printf("+ ");
			while(subcommand[increment]) {
				if (readspaces) {
					(void)printf("%s", subcommand[increment++]);
				} else {
					(void)printf("%s ", subcommand[increment++]);
				}
			}
			(void)printf("\n");
		}
		if ((pid = fork()) == -1) {
			err(EXIT_FAILURE, "fork");	
			/* NOT REACHED  */
		}
		/* child process  */
		if (pid == 0) { 
			int outputfd;	
			int inputfd;
	
			if (signal(SIGINT, SIG_DFL) == SIG_ERR) {
				(void)err(EXIT_FAILURE, "signal");
			}
			if (signal(SIGTSTP, SIG_DFL) == SIG_ERR) {
				(void)err(EXIT_FAILURE, "signal");
			}
			if (background) {
				if (signal(SIGINT, SIG_IGN) == SIG_ERR) {
					(void)err(EXIT_FAILURE, "sigprogmask");
				}	
			}
			if (pipeoutput) {
				(void)close(cpipe[0]);
				if (dup2(cpipe[1], STDOUT_FILENO) != STDOUT_FILENO) {
					(void)err(EXIT_FAILURE, "dup2");
				}
				close(cpipe[1]);	
			}
			if (readpipe != -1) {
				if (dup2(readpipe, STDIN_FILENO) != STDIN_FILENO) {
					(void)err(EXIT_FAILURE, "dup2");
				}
				(void)close(readpipe);
			}
			if (redirectfile) {
				if ((outputfd = open(redirectfile, openflags, S_IRUSR | S_IWUSR))  == -1) {
					(void)fprintf(stderr, "%s: %s: No such file or directory\n", 
						getprogname(), redirectfile);
					return EXIT_FAILURE; 
				}
				if (dup2(outputfd, STDOUT_FILENO) != STDOUT_FILENO) {
					err(EXIT_FAILURE, "dup2 to stdout");
				}
				(void)close(outputfd);
			}	
			if (stdinfile) {
				if ((inputfd = open(stdinfile, O_RDONLY)) == -1) {
					fprintf(stderr, "%s: %s: No such file or directory\n", 
						getprogname(), stdinfile);
					return EXIT_FAILURE;
				}
				if (dup2(inputfd, STDIN_FILENO) != STDIN_FILENO) {
					err(EXIT_FAILURE, "dup2 to stdin");
				}
				close(inputfd);	
			}
			if (strncmp(subcommand[0], CD_BUILTIN, strlen(subcommand[0])) == 0) {
				if (cd(subcommand, subcommandindex)) {
					_exit(EXIT_FAILURE);
				}
				_exit(EXIT_SUCCESS);
			} else if (strncmp(subcommand[0], ECHO_BUILTIN, strlen(subcommand[0])) == 0) {
				
				if (echo(subcommand, subcommandindex)) {
					_exit(EXIT_FAILURE);
				}
				_exit(EXIT_SUCCESS);
			}
			execvp(subcommand[0], subcommand);
			fprintf(stderr, "%s: %s: command not found\n", getprogname(), subcommand[0]);
			_exit(127);
		}
		/* parent process  */
		
		if (pipeoutput) {
			(void)close(cpipe[1]);
			readpipe = cpipe[0];		
		} else {
			(void)close(readpipe);
			readpipe = -1;
		}
		
		if (pid > 0) {
			if (background) {
				if (waitpid(pid, &status, WNOHANG) < 0) {
					(void)err(EXIT_FAILURE, "waitpid");
				} 
			} else {
				if ( waitpid(pid, &status, 0) < 0) {
					(void)err(EXIT_FAILURE, "waitpid");
				}
			}
		}
	}
	if (WIFEXITED(status)) {
		command->exit_code = WEXITSTATUS(status);
	} else {
		command->exit_code = EXIT_SUCCESS;	
	}
	return command->exit_code;
}
/*
 * Pipeline for converting an input string into a
 * formatted command
*/
int
process_input(char *buffer) 
{
	int i, pipe_index;
	struct command_struct *command;
			
	command  = create_command_struct(buffer);
	if ( delimit_by_pipe(command)) {
		EXIT_STATUS = SYNTAX_ERR;
	}
	if (delimit_by_redirect(command)) {
		EXIT_STATUS = SYNTAX_ERR;
	}
	if (delimit_by_space(command)) {
		EXIT_STATUS = SYNTAX_ERR;
	}
	
	command->pipe_indexes[0] = 0;
	for (i = 0, pipe_index = 1; i < command->num_tokens - 1; i++) {
		if (strncmp(command->tokenized[i], "|", strlen(command->tokenized[i])) == 0) {
			command->pipe_indexes[pipe_index++] = i;
		}
	}
	command->pipe_indexes[pipe_index] = -1;
	command->num_pipes = pipe_index + 1;
	EXIT_STATUS = execute_command(command);
	for (i = 0; i < command->num_tokens - 1; i++) {
		(void)free(command->tokenized[i]);
	}
	(void)free(command->raw);
	(void)free(command);
	return 0;
}

/*
 * sish is a basic shell, but not a scripting language. It it based on
 * /bin/sh and has support for pipes, redirects, and background commands.
*/
int
main(int argc, char **argv) 
{
	char *input;
	int opt;
	sigset_t nmask, omask;
	char buf[ARG_MAX];
	char cwd[PATH_MAX];
	
	(void)setprogname(argv[0]);
	
	while ((opt = getopt(argc, argv,"c:x")) != -1) {
		switch(opt) {
			case 'c': // command
				flags.c = optarg;	
				break;
			case 'x': // tracing
				flags.x = 1;
				break;
			default : 
				(void)printf(usage);
				return EXIT_FAILURE;
				/* NOTREACHED  */
		}
	}
	argc -= optind;
	argv += optind;
	
	if (argv[0]) {
		(void)printf(usage);
		return EXIT_FAILURE;
	}
	if (flags.c) {
		if (strlen(flags.c) == 0) {
			return 0;
		}
		if (strncmp(flags.c, EXIT_BUILTIN, strlen(flags.c)) == 0) {
			exit_sish();
		}
		process_input(flags.c);	
		return EXIT_STATUS;
	}
	
	if ((pwd = getpwuid(getuid())) == NULL) {
		(void)err(EXIT_FAILURE, "getpwuid");
	}
	if (getcwd(cwd, PATH_MAX) == NULL) {
		(void)err(EXIT_FAILURE, "getcwd");	
	}
	if (setenv("SHELL", cwd, 1) == -1) {
		(void)err(EXIT_FAILURE, "setenv");
	}	
	
	if (sigemptyset(&nmask) < 0) {
		err(EXIT_FAILURE, "sigemptyset");
	}
	if (sigaddset(&nmask, SIGCHLD) < 0) {
		err(EXIT_FAILURE, "sigaddset");
	}
	if (sigprocmask(SIG_BLOCK, &nmask, &omask) < 0) {
		err(EXIT_FAILURE, "sigprocmask");
	}
	
	if (signal(SIGINT, SIG_IGN) == SIG_ERR) {
		err(EXIT_FAILURE, "signal");
	}
	if (signal(SIGTSTP, SIG_IGN) == SIG_ERR) {
		err(EXIT_FAILURE, "signal");
	}

	for (;;) {
		printf("sish$ ");
		if ((input = fgets(buf, ARG_MAX, stdin)) == NULL) {
			if (feof(stdin) == 0) { 
				err(EXIT_FAILURE, "fgets"); 
			} else {
				printf("\n");
				exit_sish();	
			}
		}
		if (strncmp(buf, "\n", strlen(buf)) == 0) {
			continue;
		}
		buf[strlen(buf) - 1] = '\0';
		if (strncmp(input, EXIT_BUILTIN, strlen(input)) == 0) {
			exit_sish();
		}
		process_input(buf);
	}
	return EXIT_STATUS;
}
